% DI (Dependency Injection)

이 문서는 프로젝트의 DI(Dependency Injection) 시스템 사용 규칙을 정의합니다.

## 기본 구조
- `DIContainerBase`를 상속하여 컨테이너 클래스 구현
- `DIResolver`를 통해 컨테이너 등록 및 해결
- `DIResolver.Resolve<T>()`로 컨테이너 직접 조회
- `DIResolver.Inject(instance)`로 인스턴스에 의존성 주입

## 네임스페이스
- `Waving.Di`: DI 시스템 핵심 클래스 (DIResolver, DIContainerBase, DIMono)

## 컨테이너 구현 규칙
- `DIContainerBase`를 상속하여 컨테이너 클래스 작성
- 생성자에서 자동으로 `DIResolver.Register(this)` 호출됨
- `GetAllowedType()`를 오버라이드하여 주입 허용 타입 지정
- 컨테이너는 필요한 의존성을 프로퍼티로 노출

## Resolve 사용
- `DIResolver.Resolve<T>()`로 컨테이너 직접 조회
- 주로 상태 클래스 생성자에서 사용
- 컨테이너가 등록되지 않으면 null 반환, null 체크 필수

## Inject 사용
- `DIResolver.Inject(instance)`로 인스턴스에 의존성 주입
- `DIMono`를 상속한 MonoBehaviour는 `Awake()`에서 자동으로 `Inject` 호출됨
- 일반 클래스는 수동으로 `DIResolver.Inject(this)` 호출
- 주입은 `GetAllowedType()`과 호환되는 타입에만 적용됨

## DIInstaller 사용
- 씬 진입 시 `DIInstaller.Install()` 호출하여 컨테이너 생성
- `DIInstaller`는 MonoBehaviour로 씬에 배치
- 컨테이너 인스턴스는 생성자에서 자동 등록됨

## 사용 예시

### 상태 클래스에서 Resolve 사용
```csharp
public class SampleState : IState
{
    private SampleContainer _container;
    
    public SampleState()
    {
        _container = DIResolver.Resolve<SampleContainer>();
    }
    
    public void Enter() { }
    public void Execute() { }
    public void Exit() { }
}
```

### MonoBehaviour에서 Inject 사용
```csharp
public class SampleMono : DIMono
{
    private SampleContainer _container;
    
    protected override void Awake()
    {
        base.Awake(); // DIResolver.Inject(this) 자동 호출
        _container = DIResolver.Resolve<SampleContainer>();
    }
}
```

### 일반 클래스에서 Inject 사용
```csharp
public class SampleClass
{
    private SampleContainer _container;
    
    public SampleClass()
    {
        DIResolver.Inject(this);
        _container = DIResolver.Resolve<SampleContainer>();
    }
}
```

## 금지 사항
- 컨테이너 간 순환 참조 금지
- DI 없이 직접 new로 인스턴스 생성 지양 (컨테이너에서 관리되는 객체)
- `Resolve<T>()` 결과 null 체크 누락 금지
